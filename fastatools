#!/usr/bin/env bash
# This script was generated by bashly (https://github.com/DannyBen/bashly)
# Modifying it manually is not recommended

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
fastatools_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools\n"
    echo 
    printf "  Useful scripts for FASTA manipulation grouped in a single tool\n  \n  This tool follows the UNIX philosophy, meaning that it reads the satndard\n  input and writes to the standard output so it can be chained with other tools.\n  However, for each and every command there are the --input (-i) and --output\n  (-o) flags  allowing you to manually specify input and output files.\n"
    echo 
  else
    printf "fastatools - Useful scripts for FASTA manipulation grouped in a single tool\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools [command]\n"
  printf "  fastatools [command] --help | -h\n"
  printf "  fastatools --version | -v\n"
  echo
  # :command.usage_commands
  printf "Transformation Commands:\n"
  echo "  upper        Transform sequences to uppercase"
  echo "  lower        Transform sequences to lowercase"
  echo "  pretty       Wrap long sequences to a desired width"
  printf "\nSelection Commands:\n"
  echo "  select       Select sequences to keep by name"
  echo "  subset       Select sequences to keep by index"
  echo "  head         Print first sequences"
  echo "  tail         Print last sequences"
  echo "  subsite      Select specific sites of aligned FASTA sequences"
  printf "\nInformation Commands:\n"
  echo "  count        Count number of sequences in FASTA"
  echo "  names        Get names of sequences in FASTA"
  echo "  length       Get lengths of sequences in FASTA"
  echo "  freqs        Get nucleotide frequencies in sequences"
  printf "\nSplitting Commands:\n"
  echo "  split        Split FASTA file in several files"
  printf "\nName Manipulation Commands:\n"
  echo "  rename       Rename sequences in FASTA"
  echo "  addid        Add identifier at the end of sequence names"
  printf "\nMiscellaneous Commands:\n"
  echo "  completion   Generate Bash completion script"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
fastatools_upper_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools upper - Transform sequences to uppercase\n"
    echo 
  else
    printf "fastatools upper - Transform sequences to uppercase\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools upper [options]\n"
  printf "  fastatools upper --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --output, -o OUTPUTPATH"
    printf "    path to output file\n"
    echo

  fi
}

# :command.usage
fastatools_lower_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools lower - Transform sequences to lowercase\n"
    echo 
  else
    printf "fastatools lower - Transform sequences to lowercase\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools lower [options]\n"
  printf "  fastatools lower --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --output, -o OUTPUTPATH"
    printf "    path to output file\n"
    echo

  fi
}

# :command.usage
fastatools_pretty_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools pretty - Wrap long sequences to a desired width\n"
    echo 
  else
    printf "fastatools pretty - Wrap long sequences to a desired width\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools pretty [options]\n"
  printf "  fastatools pretty --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --output, -o OUTPUTPATH"
    printf "    path to output file\n"
    echo
    
    # :flag.usage
    echo "  --width, -w WIDTH"
    printf "    width at which to wrap sequences\n"
    printf "    Default: 60\n"
    echo

  fi
}

# :command.usage
fastatools_select_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools select - Select sequences to keep by name\n"
    echo 
  else
    printf "fastatools select - Select sequences to keep by name\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools select [options] [...]\n"
  printf "  fastatools select --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --output, -o OUTPUTPATH"
    printf "    path to output file\n"
    echo
    
    # :flag.usage
    echo "  --file, -f FILE"
    printf "    file with names of sequences to keep (1 name per line)\n"
    echo
    
    # :flag.usage
    echo "  --regex, -r REGEX"
    printf "    regex defining files to keep\n"
    echo
    
    # :flag.usage
    echo "  --exclude, -x"
    printf "    discards sequences instead of keeping them\n"
    echo

  fi
}

# :command.usage
fastatools_subset_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools subset\n"
    echo 
    printf "  Select sequences to keep by index\n  \n  Indices are inclusive and start at 1.\n  \n  You can select individual indices: \n    fastatools subset -i input.fa 10 20 30 \n  Or a interval: \n    fastatools subset -i input.fa --start 10 --end 20\n  \n  You can specify only one of --start/--end and to define open ended intervals. \n  If individual indices are specified, it will override any --start or --end\n  specification.\n"
    echo 
  else
    printf "fastatools subset - Select sequences to keep by index\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools subset [options] [...]\n"
  printf "  fastatools subset --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --output, -o OUTPUTPATH"
    printf "    path to output file\n"
    echo
    
    # :flag.usage
    echo "  --start, -s STARTINDEX"
    printf "    starting index\n"
    printf "    Default: 1\n"
    echo
    
    # :flag.usage
    echo "  --end, -e ENDINDEX"
    printf "    ending index\n"
    printf "    Default: 9223372036854775807\n"
    echo
    
    # :flag.usage
    echo "  --exclude, -x"
    printf "    discards sequences instead of keeping them\n"
    echo

  fi
}

# :command.usage
fastatools_head_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools head - Print first sequences\n"
    echo 
  else
    printf "fastatools head - Print first sequences\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools head [options]\n"
  printf "  fastatools head --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --number, -n NUMBER"
    printf "    number of sequences to show\n"
    printf "    Default: 10\n"
    echo
    
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --output, -o OUTPUTPATH"
    printf "    path to output file\n"
    echo

  fi
}

# :command.usage
fastatools_tail_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools tail - Print last sequences\n"
    echo 
  else
    printf "fastatools tail - Print last sequences\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools tail [options]\n"
  printf "  fastatools tail --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --number, -n NUMBER"
    printf "    number of sequences to show\n"
    printf "    Default: 10\n"
    echo
    
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --output, -o OUTPUTPATH"
    printf "    path to output file\n"
    echo

  fi
}

# :command.usage
fastatools_subsite_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools subsite\n"
    echo 
    printf "  Select specific sites of aligned FASTA sequences\n  \n  The sites can be a list of integers specified as positional arguments or in a\n  file.\n  If the sequences are not aligned (i.e they do not have the same length) a\n  warning will be thrown.\n"
    echo 
  else
    printf "fastatools subsite - Select specific sites of aligned FASTA sequences\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools subsite [options] [...]\n"
  printf "  fastatools subsite --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --output, -o OUTPUTPATH"
    printf "    path to output file\n"
    echo
    
    # :flag.usage
    echo "  --file, -f FILE"
    printf "    file with positions of am to keep (1 name per line)\n"
    echo
    
    # :flag.usage
    echo "  --fail, -x"
    printf "    Exit with an error if sequences are unaligned instead of warn.\n"
    echo

  fi
}

# :command.usage
fastatools_count_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools count - Count number of sequences in FASTA\n"
    echo 
  else
    printf "fastatools count - Count number of sequences in FASTA\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools count [options]\n"
  printf "  fastatools count --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --output, -o OUTPUTPATH"
    printf "    path to output file\n"
    echo

  fi
}

# :command.usage
fastatools_names_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools names - Get names of sequences in FASTA\n"
    echo 
  else
    printf "fastatools names - Get names of sequences in FASTA\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools names [options]\n"
  printf "  fastatools names --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --output, -o OUTPUTPATH"
    printf "    path to output file\n"
    echo

  fi
}

# :command.usage
fastatools_length_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools length - Get lengths of sequences in FASTA\n"
    echo 
  else
    printf "fastatools length - Get lengths of sequences in FASTA\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools length [options]\n"
  printf "  fastatools length --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --output, -o OUTPUTPATH"
    printf "    path to output file\n"
    echo
    
    # :flag.usage
    echo "  --mode, -m MODE"
    printf "    How to display length\n    The \"each\" mode will display length for every sequence. The \"min\", \"max\" and\n    \"mean\" modes will display the computed length over all sequences. The \"sum\"\n    option will return the sum of all sequence lengths.\n"
    printf "    Allowed: each, min, max, mean, sum\n"
    printf "    Default: each\n"
    echo
    
    # :flag.usage
    echo "  --readable, -r"
    printf "    Human readable lengths\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  # Get length of each sequence:\n  \n    fastatools length \\ \n        -i input.fasta\n  \n\n"
    printf "  # Get average length of sequences:\n  \n    fastatools length \\ \n        -i input.fasta \\ \n        -m mean\n"
    echo

  fi
}

# :command.usage
fastatools_freqs_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools freqs - Get nucleotide frequencies in sequences\n"
    echo 
  else
    printf "fastatools freqs - Get nucleotide frequencies in sequences\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools freqs [options]\n"
  printf "  fastatools freqs --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --output, -o OUTPUTPATH"
    printf "    path to output file\n"
    echo
    
    # :flag.usage
    echo "  --mean, -m"
    printf "    display the mean frequencies over all sequences\n"
    echo

  fi
}

# :command.usage
fastatools_split_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools split - Split FASTA file in several files\n"
    echo 
  else
    printf "fastatools split - Split FASTA file in several files\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools split [options]\n"
  printf "  fastatools split --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --each, -e"
    printf "    split file into individual sequences\n"
    echo
    
    # :flag.usage
    echo "  --every, -v EVERY"
    printf "    split every n sequences (incompatible with --each)\n"
    echo
    
    # :flag.usage
    echo "  --prefix, -p OUTPUTPREFIX"
    printf "    prefix for output_files\n"
    printf "    Default: split_\n"
    echo

  fi
}

# :command.usage
fastatools_rename_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools rename - Rename sequences in FASTA\n"
    echo 
  else
    printf "fastatools rename - Rename sequences in FASTA\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools rename [options] [...]\n"
  printf "  fastatools rename --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --file, -f FILE"
    printf "    path to name file (old name, new name) on each line\n"
    echo
    
    # :flag.usage
    echo "  --regex, -r REGEX"
    printf "    regex to rename file\n"
    echo
    
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --output, -o OUTPUTPATH"
    printf "    path to output file\n"
    echo

  fi
}

# :command.usage
fastatools_addid_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools addid - Add identifier at the end of sequence names\n"
    echo 
  else
    printf "fastatools addid - Add identifier at the end of sequence names\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools addid ID [options]\n"
  printf "  fastatools addid --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --prefix, -p"
    printf "    add id to beginning instead of end\n"
    echo
    
    # :flag.usage
    echo "  --input, -i INPUTPATH"
    printf "    path to input file\n"
    echo
    
    # :flag.usage
    echo "  --output, -o OUTPUTPATH"
    printf "    path to output file\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  ID"
    printf "    identifier to add to sequence names\n"
    echo

  fi
}

# :command.usage
fastatools_completion_usage() {
  if [[ -n $long_usage ]]; then
    printf "fastatools completion - Generate Bash completion script\n"
    echo 
  else
    printf "fastatools completion - Generate Bash completion script\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  fastatools completion\n"
  printf "  fastatools completion --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for (( i=0 ; i < ${#flags} ; i++ )); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if (( ${#args[@]} )); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if (( ${#other_args[@]} )); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# :src/lib/execute_command.sh

execute_command() {
    # Takes care of IO
    # $1 is the command (required)
    cmd="$1"
    # $2 is the input file (optional)
    input="$2"
    # $3 is the output file (optional)
    output="$3"
    # $4 is a piped command (optional)
    pipe="$4"
    
    
    
    if [[ -z $pipe ]]
    then
        if [[ -z $input ]]
        then
            if [[ -z $output ]]
            then
                eval "$cmd"
            else
                eval "$cmd" > "$output"
            fi
        else
            if [[ -z $output ]]
            then
                eval "$cmd" "$input"
            else
                eval "$cmd" "$input" > "$output"
            fi
        fi
    else
        if [[ -z $input ]]
        then
            if [[ -z $output ]]
            then
                eval "$cmd" "|" "$pipe"
            else
                eval "$cmd" "|" "$pipe" > "$output"
            fi
        else
            if [[ -z $output ]]
            then
                eval "$cmd" "$input" "|" "$pipe"
            else
                eval "$cmd" "$input" "|" "$pipe" > "$output"
            fi
        fi
    fi
}

# :src/lib/send_completions.sh
send_completions() {
  echo $'#!/usr/bin/env bash'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $'_fastatools_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local comp_line="${COMP_WORDS[*]:1}"'
  echo $''
  echo $'  case "$comp_line" in'
  echo $'    \'transform lower\'*) COMPREPLY=($(compgen -W "--help --input --output -h -i -o" -- "$cur")) ;;'
  echo $'    \'transform upper\'*) COMPREPLY=($(compgen -W "--help --input --output -h -i -o" -- "$cur")) ;;'
  echo $'    \'stats length\'*) COMPREPLY=($(compgen -W "--help --input --mode --output -h -i -m -o" -- "$cur")) ;;'
  echo $'    \'stats names\'*) COMPREPLY=($(compgen -W "--help --input --output -h -i -o" -- "$cur")) ;;'
  echo $'    \'stats freqs\'*) COMPREPLY=($(compgen -W "--help --input --mean --output -h -i -m -o" -- "$cur")) ;;'
  echo $'    \'stats count\'*) COMPREPLY=($(compgen -W "--help --input --output -h -i -o" -- "$cur")) ;;'
  echo $'    \'transform\'*) COMPREPLY=($(compgen -W "--help -h lower upper" -- "$cur")) ;;'
  echo $'    \'subset\'*) COMPREPLY=($(compgen -W "--exclude --file --help --input --output --regex -f -h -i -o -r -x" -- "$cur")) ;;'
  echo $'    \'stats\'*) COMPREPLY=($(compgen -W "--help -h count freqs length names" -- "$cur")) ;;'
  echo $'    \'tail\'*) COMPREPLY=($(compgen -W "--help --input --number --output -h -i -n -o" -- "$cur")) ;;'
  echo $'    \'head\'*) COMPREPLY=($(compgen -W "--help --input --number --output -h -i -n -o" -- "$cur")) ;;'
  echo $'    \'\'*) COMPREPLY=($(compgen -W "--help --version -h -v head stats subset tail transform" -- "$cur")) ;;'
  echo $'  esac'
  echo $'}'
  echo $''
  echo $'complete -F _fastatools_completions fastatools'
}

# :command.command_functions
# :command.function
fastatools_upper_command() {
  # :src/upper_command.sh
  
  
  SCRIPT='{ if ($1 ~ /^>.*$/){ print $0 } else { print toupper($0) } }'
  execute_command "awk '$SCRIPT'" "${args[--input]}" "${args[--output]}"
}

# :command.function
fastatools_lower_command() {
  # :src/lower_command.sh
  
  
  SCRIPT='{ if ($1 ~ /^>.*$/){ print $0 } else { print tolower($0) } }'
  execute_command "awk '$SCRIPT'" "${args[--input]}" "${args[--output]}"
}

# :command.function
fastatools_pretty_command() {
  # :src/pretty_command.sh
  SCRIPT="BEGIN { RS=\">\"; FS=\"\n\"; } NR>1 { tot = \"\"; for (i=2; i<NF; i++) { tot = tot  \$i } print \">\" \$1; while (length(tot) >= ${args[--width]}) { print substr(tot, 1, ${args[--width]}); tot = substr(tot, ${args[--width]} + 1); } print tot }"
  
  execute_command "awk '$SCRIPT'" "${args[--input]}" "${args[--output]}"
}

# :command.function
fastatools_select_command() {
  # :src/select_command.sh
  
  
  function join_by {
      local IFS="$1";
      shift;
      echo "$*";
  }
  
  if [[ -n ${args[--file]} ]]
  then
      joined="($(sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/|/g;s/|$//' "${args[--file]}" ))"
  elif [[ -n ${args[--regex]} ]]
  then
      joined="${args[--regex]}"
  else
      joined="($(join_by "|" ${other_args[*]} ))"
  fi
  
  if [[ ${args[--exclude]} ]]
  then
      operator="!~"
  else
      operator="~"
  fi
  
  SCRIPT="BEGIN { RS=\">\"; FS=\"\n\" } NR>1 { if (\$1 $operator /^$joined\$/) { print \">\"\$1; for (i=2; i<NF; i++) { print \$i } } }"
  
  execute_command "awk '$SCRIPT'" "${args[--input]}" "${args[--output]}"
}

# :command.function
fastatools_subset_command() {
  # :src/subset_command.sh
   
  
  join_indices()
  {
     local p="arr[$1]=$1"
     shift
     for i in "$@"
     do
        p="$p; arr[$i]=$i"
     done
     echo "$p"
  }
  
  init=""
  if [[ -n "${other_args[*]}" ]]; then
      init=$( join_indices "${other_args[@]}")
      conditional="(NR - 1 in arr)"
  else
      if [[ ${args[--start]} -eq 1 && ${args[--end]} -eq 9223372036854775807 ]]; then
          echo "
          You must indicate at least some indices you want to select.
          Either as positional arguments or specify --start and/or --end."
          exit 1
      else
          conditional="(NR - 1 >= ${args[--start]} && NR -1 <= ${args[--end]})"
      fi
  fi
  
  pre=""
  if [[ -n ${args[--exclude]} ]]
  then
      pre="!"
  fi
  
  SCRIPT="BEGIN { RS=\">\"; FS=\"\n\"; $init } NR>1 { if ($pre$conditional) { print \">\" \$1; for (i=2; i<NF; i++) { print \$i } } }"
  
  execute_command "awk '$SCRIPT'" "${args[--input]}" "${args[--output]}"
}

# :command.function
fastatools_head_command() {
  # :src/head_command.sh
   
  SCRIPT=" BEGIN { RS=\">\"; FS=\"\n\"; ORS=\"\" } NR>1{ if (FNR - 1 <= ${args[--number]}) { print \">\" \$0 } }"
  execute_command "awk '$SCRIPT'" "${args[--input]}" "${args[--output]}"
}

# :command.function
fastatools_tail_command() {
  # :src/tail_command.sh
   
  function make_script {
      LIM=$(($1-$2))
      echo "BEGIN { RS=\">\"; FS=\"\n\"; ORS=\"\" } NR>1 { if (NR > $LIM + 1) { print \">\" \$0 } }"
  }
  
  
  if [[ -z ${args[--input]} ]]
  then
      input=$(cat)
      NRECORDS=$( echo "$input" | grep -c ">" )
      SCRIPT=$(make_script "$NRECORDS" "${args[--number]}")
      echo "$SCRIPT"
  
      command="echo \"$input\" | awk '$SCRIPT'"
  else
      NRECORDS=$(grep -c ">" "${args[--input]}" )
      SCRIPT=$(make_script "$NRECORDS" "${args[--number]}")
      echo "$SCRIPT"
      command="awk '$SCRIPT'"
  fi
  
  execute_command "$command" "${args[--input]}" "${args[--output]}"
}

# :command.function
fastatools_subsite_command() {
  # :src/subsite_command.sh
  SCRIPTARGS='BEGIN { RS=">"; FS=" "; ORS="\n"; n = split(args, temp, " "); for (x in temp) { pos[temp[x]]=1 } } NR>1 {printf ">%s\n", $1; curr = 0; for (i=2; i <= NF; i++) { for (j=1; j<=length($i); j++) { curr++; if (curr in pos) { printf "%s", substr($i, j, 1) } } } printf("\n") }'
  SCRIPTFILE='BEGIN { while ( getline < file ) { pos[$0] = 1 } RS=">"; FS=" "; ORS="\n"; } NR>1 {printf ">%s\n", $1; curr = 0; for (i=2; i <= NF; i++) { for (j=1; j<=length($i); j++) { curr++; if (curr in pos) { printf "%s", substr($i, j, 1) } } } printf("\n") }'
  
  if [[ -n ${args[--file]} ]]
  then
      execute_command "awk -v file=\"${args[--file]}\" '$SCRIPTFILE'" "${args[--input]}" "${args[--output]}"
  else
      execute_command "awk -v args=\"${other_args[*]}\" '$SCRIPTARGS'" "${args[--input]}" "${args[--output]}"
  fi
}

# :command.function
fastatools_count_command() {
  # :src/count_command.sh
  
  
  execute_command 'grep -c ">"' "${args[--input]}" "${args[--output]}"
}

# :command.function
fastatools_names_command() {
  # :src/names_command.sh
  
  
  SCRIPT='BEGIN { RS=">"; FS="\n" } NR>1{ print $1 }'
  execute_command "awk '$SCRIPT'" "${args[--input]}" "${args[--output]}"
}

# :command.function
fastatools_length_command() {
  # :src/length_command.sh
  
  SCRIPTEACH='BEGIN { RS=">"; FS="\n"; OFS="\t"; } NR>1{ linelen=0; for (i=2; i<NF; i++) { linelen=linelen+length($i) } print $1, linelen }'
  
  SCRIPTMAX='BEGIN { RS=">"; FS="\n"; OFS="\t"; max=0; } NR>1{ linelen=0; for (i=2; i<NF; i++) { linelen=linelen+length($i) } if (linelen > max) { max=linelen } } END{ print max }'
  
  SCRIPTMIN='BEGIN { RS=">"; FS="\n"; OFS="\t"; min=-1; } NR>1{ linelen=0; for (i=2; i<NF; i++) { linelen=linelen+length($i) } if (linelen < min || min == -1) { min=linelen } } END{ print min }'
  
  SCRIPTMEAN='BEGIN { RS=">"; FS="\n"; OFS="\t"; total=0; count=0; } NR>1{ linelen=0; for (i=2; i<NF; i++) { total=total+length($i) } count++ } END{ print total/count }'
  
  SCRIPTSUM='BEGIN { RS=">"; FS="\n"; OFS="\t"; } NR>1{ linelen=0; for (i=2; i<NF; i++) { linelen=linelen+length($i) } total += linelen } END {print total}'
  
  FIELD=1
  case ${args[--mode]} in
      
      each)
          SCRIPT=$SCRIPTEACH
          FIELD=2
      ;;
      min)
          SCRIPT=$SCRIPTMIN
      ;;
      max)
          SCRIPT=$SCRIPTMAX
      ;;
      mean)
          SCRIPT=$SCRIPTMEAN
      ;;
      sum)
          SCRIPT=$SCRIPTSUM
      ;;
  esac
  
  if [[ -n ${args[--readable]} ]]
  then
      execute_command "awk '$SCRIPT'" "${args[--input]}" "${args[--output]}" "numfmt --to=si --field=$FIELD --format=\"%.2f\""
  else
      execute_command "awk '$SCRIPT'" "${args[--input]}" "${args[--output]}"
  fi
}

# :command.function
fastatools_freqs_command() {
  # :src/freqs_command.sh
   
  
  SCRIPTEACH='BEGIN { RS=">"; FS = " "; ORS="\n"; OFS = "\t"; } NR>1 { for (i=2; i <= NF; i++ ) { for (j=1; j<=length($i); j++) { counts[substr($i,j,1)]++; generalCount[substr($i,j,1)]++; lengths[$1]++; } } printf("%s:\n", $1); for (char in counts) { print char, counts[char], counts[char] / lengths[$1]; delete counts[char]; } printf("\n") }'
  
  SCRIPTMEAN='BEGIN { RS=">"; FS = " "; ORS="\n"; OFS = "\t"; total=0; } NR>1{ for (i=2; i <= NF; i++ ) { for (j=1; j<=length($i); j++) { generalCount[substr($i,j,1)]++; total++; } } } END { for (char in generalCount) { print char, generalCount[char] / total } }'
  
  if [ ${args[--mean]} ]
  then
      SCRIPT=$SCRIPTMEAN
  else
      SCRIPT=$SCRIPTEACH
  fi
  
  execute_command "awk '$SCRIPT'" "${args[--input]}" "${args[--output]}"
}

# :command.function
fastatools_split_command() {
  # :src/split_command.sh
  
  if [[ -z "${args[--each]}" && -z "${args[--every]}" ]]
  then
      echo "You must specify either --each or --every"
      echo ""
      fastatools_split_usage
      exit 1
  fi
  
  if [[ -n "${args[--each]}" && -n "${args[--every]}" ]]
  then
      echo "You can only specify one of --each or --every"
      echo ""
      fastatools_split_usage
      exit 1
  fi
  
  SCRIPT=""
  P="${args[--prefix]}"
  
  if [[ -n "${args[--each]}" ]]
  then
      SCRIPT="BEGIN{ RS=\">\"; FS=\"\n\" } NR>1 { fname=\"$P\"\$1\".fa\"; print \">\"\$1 > fname; for (i=2; i<NF; i++) { print \$i > fname; } }"
  fi
  
  if [[ -n "${args[--every]}" ]]
  then
      E="${args[--every]}"
      SCRIPT="BEGIN{ RS=\">\"; FS=\"\n\"; counter=0; n_seqs=0 } NR>1 { n_seqs++; if (n_seqs == ($E + 1)) { counter++; n_seqs =1; } fname=\"$P\"counter\".fa\"; print \">\"\$1 > fname; for (i=2; i<NF; i++) { print \$i > fname; } }"
  fi
  
  execute_command "awk '$SCRIPT'" "${args[--input]}"
}

# :command.function
fastatools_rename_command() {
  # :src/rename_command.sh
  echo "# this file is located in 'src/rename_command.sh'"
  echo "# code for 'fastatools rename' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  inspect_args
}

# :command.function
fastatools_addid_command() {
  # :src/addid_command.sh
  
  if [[ -z ${args[--prefix]} ]]
  then
      printer="print \">\" \$1 \"${args[id]}\""
  else
      printer="print \">\" \"${args[id]}\" \$1"
  fi
  
  SCRIPT="BEGIN { RS=\">\"; FS=\"\n\"; } NR>1 { $printer; for (i=2; i<NF; i++) { print \$i } }"
  execute_command "awk '$SCRIPT'" "${args[--input]}" "${args[--output]}"
}

# :command.function
fastatools_completion_command() {
  # :src/completion_command.sh
   
  send_completions
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=$1
  
  case $action in
  -* )
    ;;
  
  upper )
    action="upper"
    shift
    fastatools_upper_parse_requirements "$@"
    shift $#
    ;;    
  
  lower )
    action="lower"
    shift
    fastatools_lower_parse_requirements "$@"
    shift $#
    ;;    
  
  pretty )
    action="pretty"
    shift
    fastatools_pretty_parse_requirements "$@"
    shift $#
    ;;    
  
  select )
    action="select"
    shift
    fastatools_select_parse_requirements "$@"
    shift $#
    ;;    
  
  subset )
    action="subset"
    shift
    fastatools_subset_parse_requirements "$@"
    shift $#
    ;;    
  
  head )
    action="head"
    shift
    fastatools_head_parse_requirements "$@"
    shift $#
    ;;    
  
  tail )
    action="tail"
    shift
    fastatools_tail_parse_requirements "$@"
    shift $#
    ;;    
  
  subsite )
    action="subsite"
    shift
    fastatools_subsite_parse_requirements "$@"
    shift $#
    ;;    
  
  count )
    action="count"
    shift
    fastatools_count_parse_requirements "$@"
    shift $#
    ;;    
  
  names )
    action="names"
    shift
    fastatools_names_parse_requirements "$@"
    shift $#
    ;;    
  
  length )
    action="length"
    shift
    fastatools_length_parse_requirements "$@"
    shift $#
    ;;    
  
  freqs )
    action="freqs"
    shift
    fastatools_freqs_parse_requirements "$@"
    shift $#
    ;;    
  
  split )
    action="split"
    shift
    fastatools_split_parse_requirements "$@"
    shift $#
    ;;    
  
  rename )
    action="rename"
    shift
    fastatools_rename_parse_requirements "$@"
    shift $#
    ;;    
  
  addid )
    action="addid"
    shift
    fastatools_addid_parse_requirements "$@"
    shift $#
    ;;    
  
  completion )
    action="completion"
    shift
    fastatools_completion_parse_requirements "$@"
    shift $#
    ;;    
  
  # :command.command_fallback
  * )
    fastatools_usage
    exit 1
    ;;
  
  esac
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_upper_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_upper_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="upper"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUTPATH"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_lower_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_lower_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="lower"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUTPATH"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_pretty_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_pretty_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="pretty"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --width | -w )
      if [[ $2 ]]; then
        args[--width]="$2"
        shift
        shift
      else
        printf "%s\n" "--width requires an argument: --width, -w WIDTH"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--width]} ]] || args[--width]="60"
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_select_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_select_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="select"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --file | -f )
      if [[ $2 ]]; then
        args[--file]="$2"
        shift
        shift
      else
        printf "%s\n" "--file requires an argument: --file, -f FILE"
        exit 1
      fi
      ;;
  
    # :flag.case
    --regex | -r )
      if [[ $2 ]]; then
        args[--regex]="$2"
        shift
        shift
      else
        printf "%s\n" "--regex requires an argument: --regex, -r REGEX"
        exit 1
      fi
      ;;
  
    # :flag.case
    --exclude | -x )
      args[--exclude]=1
      shift
      ;;
  
  
    -* )
      other_args+=("$1")
      shift
      ;;
  
    * )
      # :command.parse_requirements_case
        other_args+=("$1")
        shift
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_subset_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_subset_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="subset"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --start | -s )
      if [[ $2 ]]; then
        args[--start]="$2"
        shift
        shift
      else
        printf "%s\n" "--start requires an argument: --start, -s STARTINDEX"
        exit 1
      fi
      ;;
  
    # :flag.case
    --end | -e )
      if [[ $2 ]]; then
        args[--end]="$2"
        shift
        shift
      else
        printf "%s\n" "--end requires an argument: --end, -e ENDINDEX"
        exit 1
      fi
      ;;
  
    # :flag.case
    --exclude | -x )
      args[--exclude]=1
      shift
      ;;
  
  
    -* )
      other_args+=("$1")
      shift
      ;;
  
    * )
      # :command.parse_requirements_case
        other_args+=("$1")
        shift
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--start]} ]] || args[--start]="1"
  [[ -n ${args[--end]} ]] || args[--end]="9223372036854775807"
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_head_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_head_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="head"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --number | -n )
      if [[ $2 ]]; then
        args[--number]="$2"
        shift
        shift
      else
        printf "%s\n" "--number requires an argument: --number, -n NUMBER"
        exit 1
      fi
      ;;
  
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUTPATH"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--number]} ]] || args[--number]="10"
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_tail_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_tail_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="tail"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --number | -n )
      if [[ $2 ]]; then
        args[--number]="$2"
        shift
        shift
      else
        printf "%s\n" "--number requires an argument: --number, -n NUMBER"
        exit 1
      fi
      ;;
  
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUTPATH"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--number]} ]] || args[--number]="10"
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_subsite_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_subsite_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="subsite"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --file | -f )
      if [[ $2 ]]; then
        args[--file]="$2"
        shift
        shift
      else
        printf "%s\n" "--file requires an argument: --file, -f FILE"
        exit 1
      fi
      ;;
  
    # :flag.case
    --fail | -x )
      args[--fail]=1
      shift
      ;;
  
  
    -* )
      other_args+=("$1")
      shift
      ;;
  
    * )
      # :command.parse_requirements_case
        other_args+=("$1")
        shift
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_count_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_count_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="count"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUTPATH"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_names_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_names_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="names"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUTPATH"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_length_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_length_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="length"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --mode | -m )
      if [[ $2 ]]; then
        args[--mode]="$2"
        shift
        shift
      else
        printf "%s\n" "--mode requires an argument: --mode, -m MODE"
        exit 1
      fi
      ;;
  
    # :flag.case
    --readable | -r )
      args[--readable]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--mode]} ]] || args[--mode]="each"
  # :command.whitelist_filter
  if [[ ! ${args[--mode]} =~ ^(each|min|max|mean|sum)$ ]]; then
    printf "%s\n" "--mode must be one of: each, min, max, mean, sum"
    exit 1
  fi
}

# :command.parse_requirements
fastatools_freqs_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_freqs_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="freqs"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --mean | -m )
      args[--mean]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_split_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_split_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="split"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --each | -e )
      args[--each]=1
      shift
      ;;
  
    # :flag.case
    --every | -v )
      if [[ $2 ]]; then
        args[--every]="$2"
        shift
        shift
      else
        printf "%s\n" "--every requires an argument: --every, -v EVERY"
        exit 1
      fi
      ;;
  
    # :flag.case
    --prefix | -p )
      if [[ $2 ]]; then
        args[--prefix]="$2"
        shift
        shift
      else
        printf "%s\n" "--prefix requires an argument: --prefix, -p OUTPUTPREFIX"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  [[ -n ${args[--prefix]} ]] || args[--prefix]="split_"
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_rename_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_rename_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="rename"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --file | -f )
      if [[ $2 ]]; then
        args[--file]="$2"
        shift
        shift
      else
        printf "%s\n" "--file requires an argument: --file, -f FILE"
        exit 1
      fi
      ;;
  
    # :flag.case
    --regex | -r )
      if [[ $2 ]]; then
        args[--regex]="$2"
        shift
        shift
      else
        printf "%s\n" "--regex requires an argument: --regex, -r REGEX"
        exit 1
      fi
      ;;
  
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUTPATH"
        exit 1
      fi
      ;;
  
  
    -* )
      other_args+=("$1")
      shift
      ;;
  
    * )
      # :command.parse_requirements_case
        other_args+=("$1")
        shift
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_addid_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_addid_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="addid"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[id]=$1
    shift
  else
    printf "missing required argument: ID\nusage: fastatools addid ID [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --prefix | -p )
      args[--prefix]=1
      shift
      ;;
  
    # :flag.case
    --input | -i )
      if [[ $2 ]]; then
        args[--input]="$2"
        shift
        shift
      else
        printf "%s\n" "--input requires an argument: --input, -i INPUTPATH"
        exit 1
      fi
      ;;
  
    # :flag.case
    --output | -o )
      if [[ $2 ]]; then
        args[--output]="$2"
        shift
        shift
      else
        printf "%s\n" "--output requires an argument: --output, -o OUTPUTPATH"
        exit 1
      fi
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[id]} ]]; then
        args[id]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.parse_requirements
fastatools_completion_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    fastatools_completion_usage
    exit
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="completion"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.catch_all_filter
  # :command.default_assignments
  # :command.whitelist_filter
}

# :command.initialize
initialize() {
  version="0.1.0a"
  long_usage=''
  set -e

  if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
    printf "bash version 4 or higher is required\n"
    exit 1
  fi

  # :src/initialize.sh
  # Code here runs inside the initialize() function
  # Use it for anything that you need to run before any other function, like
  # setting environment vairables:
  # CONFIG_FILE=settings.ini
  #
  # Feel free to empty (but not delete) this file.
}

# :command.run
run() {
  declare -A args
  declare -a other_args
  declare -a input
  normalize_input "$@"
  parse_requirements "${input[@]}"

  if [[ $action == "upper" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_upper_usage
    else
      fastatools_upper_command
    fi
  
  elif [[ $action == "lower" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_lower_usage
    else
      fastatools_lower_command
    fi
  
  elif [[ $action == "pretty" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_pretty_usage
    else
      fastatools_pretty_command
    fi
  
  elif [[ $action == "select" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_select_usage
    else
      fastatools_select_command
    fi
  
  elif [[ $action == "subset" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_subset_usage
    else
      fastatools_subset_command
    fi
  
  elif [[ $action == "head" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_head_usage
    else
      fastatools_head_command
    fi
  
  elif [[ $action == "tail" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_tail_usage
    else
      fastatools_tail_command
    fi
  
  elif [[ $action == "subsite" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_subsite_usage
    else
      fastatools_subsite_command
    fi
  
  elif [[ $action == "count" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_count_usage
    else
      fastatools_count_command
    fi
  
  elif [[ $action == "names" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_names_usage
    else
      fastatools_names_command
    fi
  
  elif [[ $action == "length" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_length_usage
    else
      fastatools_length_command
    fi
  
  elif [[ $action == "freqs" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_freqs_usage
    else
      fastatools_freqs_command
    fi
  
  elif [[ $action == "split" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_split_usage
    else
      fastatools_split_command
    fi
  
  elif [[ $action == "rename" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_rename_usage
    else
      fastatools_rename_command
    fi
  
  elif [[ $action == "addid" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_addid_usage
    else
      fastatools_addid_command
    fi
  
  elif [[ $action == "completion" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      fastatools_completion_usage
    else
      fastatools_completion_command
    fi
  
  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
